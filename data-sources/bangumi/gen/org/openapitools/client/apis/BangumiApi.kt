/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.CharacterDetail
import org.openapitools.client.models.CharacterPerson
import org.openapitools.client.models.CharacterRevision
import org.openapitools.client.models.DetailedRevision
import org.openapitools.client.models.EpType
import org.openapitools.client.models.EpisodeDetail
import org.openapitools.client.models.GetUserSubjectEpisodeCollection200Response
import org.openapitools.client.models.Index
import org.openapitools.client.models.IndexBasicInfo
import org.openapitools.client.models.IndexSubjectAddInfo
import org.openapitools.client.models.IndexSubjectEditInfo
import org.openapitools.client.models.PagedEpisode
import org.openapitools.client.models.PagedRevision
import org.openapitools.client.models.PagedUserCollection
import org.openapitools.client.models.PatchUserSubjectEpisodeCollectionRequest
import org.openapitools.client.models.PersonCharacter
import org.openapitools.client.models.PersonDetail
import org.openapitools.client.models.PersonRevision
import org.openapitools.client.models.PutUserEpisodeCollectionRequest
import org.openapitools.client.models.RelatedCharacter
import org.openapitools.client.models.RelatedPerson
import org.openapitools.client.models.SearchSubjects200Response
import org.openapitools.client.models.SearchSubjectsRequest
import org.openapitools.client.models.Subject
import org.openapitools.client.models.SubjectCollectionType
import org.openapitools.client.models.SubjectRevision
import org.openapitools.client.models.SubjectType
import org.openapitools.client.models.User
import org.openapitools.client.models.UserEpisodeCollection
import org.openapitools.client.models.UserSubjectCollection
import org.openapitools.client.models.UserSubjectCollectionModifyPayload
import org.openapitools.client.models.V0RelatedSubject
import org.openapitools.client.models.V0SubjectRelation

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success

class BangumiApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Add a subject to Index
     * 
     * @param indexId 目录 ID
     * @param indexSubjectAddInfo  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addSubjectToIndexByIndexId(indexId: kotlin.Int, indexSubjectAddInfo: IndexSubjectAddInfo? = null) : Unit {
        val localVarResponse = addSubjectToIndexByIndexIdWithHttpInfo(indexId = indexId, indexSubjectAddInfo = indexSubjectAddInfo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Add a subject to Index
     * 
     * @param indexId 目录 ID
     * @param indexSubjectAddInfo  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun addSubjectToIndexByIndexIdWithHttpInfo(indexId: kotlin.Int, indexSubjectAddInfo: IndexSubjectAddInfo?) : ApiResponse<Unit?> {
        val localVariableConfig = addSubjectToIndexByIndexIdRequestConfig(indexId = indexId, indexSubjectAddInfo = indexSubjectAddInfo)

        return request<IndexSubjectAddInfo, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addSubjectToIndexByIndexId
     *
     * @param indexId 目录 ID
     * @param indexSubjectAddInfo  (optional)
     * @return RequestConfig
     */
    fun addSubjectToIndexByIndexIdRequestConfig(indexId: kotlin.Int, indexSubjectAddInfo: IndexSubjectAddInfo?) : RequestConfig<IndexSubjectAddInfo> {
        val localVariableBody = indexSubjectAddInfo
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v0/indices/{index_id}/subjects".replace("{"+"index_id"+"}", encodeURIComponent(indexId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Collect index for current user
     * 为当前用户收藏一条目录
     * @param indexId 目录 ID
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun collectIndexByIndexIdAndUserId(indexId: kotlin.Int) : Unit {
        val localVarResponse = collectIndexByIndexIdAndUserIdWithHttpInfo(indexId = indexId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Collect index for current user
     * 为当前用户收藏一条目录
     * @param indexId 目录 ID
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun collectIndexByIndexIdAndUserIdWithHttpInfo(indexId: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = collectIndexByIndexIdAndUserIdRequestConfig(indexId = indexId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation collectIndexByIndexIdAndUserId
     *
     * @param indexId 目录 ID
     * @return RequestConfig
     */
    fun collectIndexByIndexIdAndUserIdRequestConfig(indexId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v0/indices/{index_id}/collect".replace("{"+"index_id"+"}", encodeURIComponent(indexId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete a subject from a Index
     * 
     * @param indexId 目录 ID
     * @param subjectId 条目 ID
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun delelteSubjectFromIndexByIndexIdAndSubjectID(indexId: kotlin.Int, subjectId: kotlin.Int) : Unit {
        val localVarResponse = delelteSubjectFromIndexByIndexIdAndSubjectIDWithHttpInfo(indexId = indexId, subjectId = subjectId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete a subject from a Index
     * 
     * @param indexId 目录 ID
     * @param subjectId 条目 ID
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun delelteSubjectFromIndexByIndexIdAndSubjectIDWithHttpInfo(indexId: kotlin.Int, subjectId: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = delelteSubjectFromIndexByIndexIdAndSubjectIDRequestConfig(indexId = indexId, subjectId = subjectId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation delelteSubjectFromIndexByIndexIdAndSubjectID
     *
     * @param indexId 目录 ID
     * @param subjectId 条目 ID
     * @return RequestConfig
     */
    fun delelteSubjectFromIndexByIndexIdAndSubjectIDRequestConfig(indexId: kotlin.Int, subjectId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/v0/indices/{index_id}/subjects/{subject_id}".replace("{"+"index_id"+"}", encodeURIComponent(indexId.toString())).replace("{"+"subject_id"+"}", encodeURIComponent(subjectId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Edit index&#39;s information
     * 
     * @param indexId 目录 ID
     * @param indexBasicInfo  (optional)
     * @return Index
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun editIndexById(indexId: kotlin.Int, indexBasicInfo: IndexBasicInfo? = null) : Index {
        val localVarResponse = editIndexByIdWithHttpInfo(indexId = indexId, indexBasicInfo = indexBasicInfo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Index
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Edit index&#39;s information
     * 
     * @param indexId 目录 ID
     * @param indexBasicInfo  (optional)
     * @return ApiResponse<Index?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun editIndexByIdWithHttpInfo(indexId: kotlin.Int, indexBasicInfo: IndexBasicInfo?) : ApiResponse<Index?> {
        val localVariableConfig = editIndexByIdRequestConfig(indexId = indexId, indexBasicInfo = indexBasicInfo)

        return request<IndexBasicInfo, Index>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation editIndexById
     *
     * @param indexId 目录 ID
     * @param indexBasicInfo  (optional)
     * @return RequestConfig
     */
    fun editIndexByIdRequestConfig(indexId: kotlin.Int, indexBasicInfo: IndexBasicInfo?) : RequestConfig<IndexBasicInfo> {
        val localVariableBody = indexBasicInfo
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/v0/indices/{index_id}".replace("{"+"index_id"+"}", encodeURIComponent(indexId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Edit subject information in a index
     * 如果条目不存在于目录，会创建该条目
     * @param indexId 目录 ID
     * @param subjectId 条目 ID
     * @param indexSubjectEditInfo  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun editIndexSubjectsByIndexIdAndSubjectID(indexId: kotlin.Int, subjectId: kotlin.Int, indexSubjectEditInfo: IndexSubjectEditInfo? = null) : Unit {
        val localVarResponse = editIndexSubjectsByIndexIdAndSubjectIDWithHttpInfo(indexId = indexId, subjectId = subjectId, indexSubjectEditInfo = indexSubjectEditInfo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Edit subject information in a index
     * 如果条目不存在于目录，会创建该条目
     * @param indexId 目录 ID
     * @param subjectId 条目 ID
     * @param indexSubjectEditInfo  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun editIndexSubjectsByIndexIdAndSubjectIDWithHttpInfo(indexId: kotlin.Int, subjectId: kotlin.Int, indexSubjectEditInfo: IndexSubjectEditInfo?) : ApiResponse<Unit?> {
        val localVariableConfig = editIndexSubjectsByIndexIdAndSubjectIDRequestConfig(indexId = indexId, subjectId = subjectId, indexSubjectEditInfo = indexSubjectEditInfo)

        return request<IndexSubjectEditInfo, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation editIndexSubjectsByIndexIdAndSubjectID
     *
     * @param indexId 目录 ID
     * @param subjectId 条目 ID
     * @param indexSubjectEditInfo  (optional)
     * @return RequestConfig
     */
    fun editIndexSubjectsByIndexIdAndSubjectIDRequestConfig(indexId: kotlin.Int, subjectId: kotlin.Int, indexSubjectEditInfo: IndexSubjectEditInfo?) : RequestConfig<IndexSubjectEditInfo> {
        val localVariableBody = indexSubjectEditInfo
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/v0/indices/{index_id}/subjects/{subject_id}".replace("{"+"index_id"+"}", encodeURIComponent(indexId.toString())).replace("{"+"subject_id"+"}", encodeURIComponent(subjectId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Character Detail
     * cache with 60s
     * @param characterId 角色 ID
     * @return CharacterDetail
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCharacterById(characterId: kotlin.Int) : CharacterDetail {
        val localVarResponse = getCharacterByIdWithHttpInfo(characterId = characterId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CharacterDetail
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Character Detail
     * cache with 60s
     * @param characterId 角色 ID
     * @return ApiResponse<CharacterDetail?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCharacterByIdWithHttpInfo(characterId: kotlin.Int) : ApiResponse<CharacterDetail?> {
        val localVariableConfig = getCharacterByIdRequestConfig(characterId = characterId)

        return request<Unit, CharacterDetail>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCharacterById
     *
     * @param characterId 角色 ID
     * @return RequestConfig
     */
    fun getCharacterByIdRequestConfig(characterId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/characters/{character_id}".replace("{"+"character_id"+"}", encodeURIComponent(characterId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get Character Image
     * 
     * @param characterId 角色 ID
     * @param type 枚举值 {small|grid|large|medium}
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCharacterImageById(characterId: kotlin.Int, type: kotlin.String) : Unit {
        val localVarResponse = getCharacterImageByIdWithHttpInfo(characterId = characterId, type = type)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Character Image
     * 
     * @param characterId 角色 ID
     * @param type 枚举值 {small|grid|large|medium}
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getCharacterImageByIdWithHttpInfo(characterId: kotlin.Int, type: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = getCharacterImageByIdRequestConfig(characterId = characterId, type = type)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCharacterImageById
     *
     * @param characterId 角色 ID
     * @param type 枚举值 {small|grid|large|medium}
     * @return RequestConfig
     */
    fun getCharacterImageByIdRequestConfig(characterId: kotlin.Int, type: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("type", listOf(type.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/characters/{character_id}/image".replace("{"+"character_id"+"}", encodeURIComponent(characterId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Character Revision
     * 
     * @param revisionId 版本 ID
     * @return CharacterRevision
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCharacterRevisionByRevisionId(revisionId: kotlin.Int) : CharacterRevision {
        val localVarResponse = getCharacterRevisionByRevisionIdWithHttpInfo(revisionId = revisionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CharacterRevision
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Character Revision
     * 
     * @param revisionId 版本 ID
     * @return ApiResponse<CharacterRevision?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCharacterRevisionByRevisionIdWithHttpInfo(revisionId: kotlin.Int) : ApiResponse<CharacterRevision?> {
        val localVariableConfig = getCharacterRevisionByRevisionIdRequestConfig(revisionId = revisionId)

        return request<Unit, CharacterRevision>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCharacterRevisionByRevisionId
     *
     * @param revisionId 版本 ID
     * @return RequestConfig
     */
    fun getCharacterRevisionByRevisionIdRequestConfig(revisionId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/revisions/characters/{revision_id}".replace("{"+"revision_id"+"}", encodeURIComponent(revisionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get Character Revisions
     * 
     * @param characterId 角色 ID
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return PagedRevision
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCharacterRevisions(characterId: kotlin.Int, limit: kotlin.Int? = 30, offset: kotlin.Int? = 0) : PagedRevision {
        val localVarResponse = getCharacterRevisionsWithHttpInfo(characterId = characterId, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PagedRevision
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Character Revisions
     * 
     * @param characterId 角色 ID
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return ApiResponse<PagedRevision?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCharacterRevisionsWithHttpInfo(characterId: kotlin.Int, limit: kotlin.Int?, offset: kotlin.Int?) : ApiResponse<PagedRevision?> {
        val localVariableConfig = getCharacterRevisionsRequestConfig(characterId = characterId, limit = limit, offset = offset)

        return request<Unit, PagedRevision>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCharacterRevisions
     *
     * @param characterId 角色 ID
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return RequestConfig
     */
    fun getCharacterRevisionsRequestConfig(characterId: kotlin.Int, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("character_id", listOf(characterId.toString()))
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/revisions/characters",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get Episode
     * 
     * @param episodeId 章节 ID
     * @return EpisodeDetail
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEpisodeById(episodeId: kotlin.Int) : EpisodeDetail {
        val localVarResponse = getEpisodeByIdWithHttpInfo(episodeId = episodeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EpisodeDetail
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Episode
     * 
     * @param episodeId 章节 ID
     * @return ApiResponse<EpisodeDetail?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEpisodeByIdWithHttpInfo(episodeId: kotlin.Int) : ApiResponse<EpisodeDetail?> {
        val localVariableConfig = getEpisodeByIdRequestConfig(episodeId = episodeId)

        return request<Unit, EpisodeDetail>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEpisodeById
     *
     * @param episodeId 章节 ID
     * @return RequestConfig
     */
    fun getEpisodeByIdRequestConfig(episodeId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/episodes/{episode_id}".replace("{"+"episode_id"+"}", encodeURIComponent(episodeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Episode Revision
     * 
     * @param revisionId 版本 ID
     * @return DetailedRevision
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEpisodeRevisionByRevisionId(revisionId: kotlin.Int) : DetailedRevision {
        val localVarResponse = getEpisodeRevisionByRevisionIdWithHttpInfo(revisionId = revisionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DetailedRevision
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Episode Revision
     * 
     * @param revisionId 版本 ID
     * @return ApiResponse<DetailedRevision?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEpisodeRevisionByRevisionIdWithHttpInfo(revisionId: kotlin.Int) : ApiResponse<DetailedRevision?> {
        val localVariableConfig = getEpisodeRevisionByRevisionIdRequestConfig(revisionId = revisionId)

        return request<Unit, DetailedRevision>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEpisodeRevisionByRevisionId
     *
     * @param revisionId 版本 ID
     * @return RequestConfig
     */
    fun getEpisodeRevisionByRevisionIdRequestConfig(revisionId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/revisions/episodes/{revision_id}".replace("{"+"revision_id"+"}", encodeURIComponent(revisionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get Episode Revisions
     * 
     * @param episodeId 章节 ID
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return PagedRevision
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEpisodeRevisions(episodeId: kotlin.Int, limit: kotlin.Int? = 30, offset: kotlin.Int? = 0) : PagedRevision {
        val localVarResponse = getEpisodeRevisionsWithHttpInfo(episodeId = episodeId, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PagedRevision
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Episode Revisions
     * 
     * @param episodeId 章节 ID
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return ApiResponse<PagedRevision?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEpisodeRevisionsWithHttpInfo(episodeId: kotlin.Int, limit: kotlin.Int?, offset: kotlin.Int?) : ApiResponse<PagedRevision?> {
        val localVariableConfig = getEpisodeRevisionsRequestConfig(episodeId = episodeId, limit = limit, offset = offset)

        return request<Unit, PagedRevision>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEpisodeRevisions
     *
     * @param episodeId 章节 ID
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return RequestConfig
     */
    fun getEpisodeRevisionsRequestConfig(episodeId: kotlin.Int, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("episode_id", listOf(episodeId.toString()))
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/revisions/episodes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get Episodes
     * 
     * @param subjectId 条目 ID
     * @param type 参照章节的&#x60;type&#x60; (optional)
     * @param limit 分页参数 (optional, default to 100)
     * @param offset 分页参数 (optional, default to 0)
     * @return PagedEpisode
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEpisodes(subjectId: kotlin.Int, type: EpType? = null, limit: kotlin.Int? = 100, offset: kotlin.Int? = 0) : PagedEpisode {
        val localVarResponse = getEpisodesWithHttpInfo(subjectId = subjectId, type = type, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PagedEpisode
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Episodes
     * 
     * @param subjectId 条目 ID
     * @param type 参照章节的&#x60;type&#x60; (optional)
     * @param limit 分页参数 (optional, default to 100)
     * @param offset 分页参数 (optional, default to 0)
     * @return ApiResponse<PagedEpisode?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEpisodesWithHttpInfo(subjectId: kotlin.Int, type: EpType?, limit: kotlin.Int?, offset: kotlin.Int?) : ApiResponse<PagedEpisode?> {
        val localVariableConfig = getEpisodesRequestConfig(subjectId = subjectId, type = type, limit = limit, offset = offset)

        return request<Unit, PagedEpisode>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEpisodes
     *
     * @param subjectId 条目 ID
     * @param type 参照章节的&#x60;type&#x60; (optional)
     * @param limit 分页参数 (optional, default to 100)
     * @param offset 分页参数 (optional, default to 0)
     * @return RequestConfig
     */
    fun getEpisodesRequestConfig(subjectId: kotlin.Int, type: EpType?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("subject_id", listOf(subjectId.toString()))
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/episodes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Index By ID
     * 
     * @param indexId 目录 ID
     * @return Index
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getIndexById(indexId: kotlin.Int) : Index {
        val localVarResponse = getIndexByIdWithHttpInfo(indexId = indexId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Index
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Index By ID
     * 
     * @param indexId 目录 ID
     * @return ApiResponse<Index?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getIndexByIdWithHttpInfo(indexId: kotlin.Int) : ApiResponse<Index?> {
        val localVariableConfig = getIndexByIdRequestConfig(indexId = indexId)

        return request<Unit, Index>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getIndexById
     *
     * @param indexId 目录 ID
     * @return RequestConfig
     */
    fun getIndexByIdRequestConfig(indexId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/indices/{index_id}".replace("{"+"index_id"+"}", encodeURIComponent(indexId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Index Subjects
     * 
     * @param indexId 目录 ID
     * @param type 条目类型 (optional)
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getIndexSubjectsByIndexId(indexId: kotlin.Int, type: SubjectType? = null, limit: kotlin.Int? = 30, offset: kotlin.Int? = 0) : Unit {
        val localVarResponse = getIndexSubjectsByIndexIdWithHttpInfo(indexId = indexId, type = type, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Index Subjects
     * 
     * @param indexId 目录 ID
     * @param type 条目类型 (optional)
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getIndexSubjectsByIndexIdWithHttpInfo(indexId: kotlin.Int, type: SubjectType?, limit: kotlin.Int?, offset: kotlin.Int?) : ApiResponse<Unit?> {
        val localVariableConfig = getIndexSubjectsByIndexIdRequestConfig(indexId = indexId, type = type, limit = limit, offset = offset)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getIndexSubjectsByIndexId
     *
     * @param indexId 目录 ID
     * @param type 条目类型 (optional)
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return RequestConfig
     */
    fun getIndexSubjectsByIndexIdRequestConfig(indexId: kotlin.Int, type: SubjectType?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/indices/{index_id}/subjects".replace("{"+"index_id"+"}", encodeURIComponent(indexId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get User
     * 返回当前 Access Token 对应的用户信息
     * @return User
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMyself() : User {
        val localVarResponse = getMyselfWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as User
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get User
     * 返回当前 Access Token 对应的用户信息
     * @return ApiResponse<User?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMyselfWithHttpInfo() : ApiResponse<User?> {
        val localVariableConfig = getMyselfRequestConfig()

        return request<Unit, User>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMyself
     *
     * @return RequestConfig
     */
    fun getMyselfRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/me",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Person
     * cache with 60s
     * @param personId 人物 ID
     * @return PersonDetail
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPersonById(personId: kotlin.Int) : PersonDetail {
        val localVarResponse = getPersonByIdWithHttpInfo(personId = personId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PersonDetail
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Person
     * cache with 60s
     * @param personId 人物 ID
     * @return ApiResponse<PersonDetail?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPersonByIdWithHttpInfo(personId: kotlin.Int) : ApiResponse<PersonDetail?> {
        val localVariableConfig = getPersonByIdRequestConfig(personId = personId)

        return request<Unit, PersonDetail>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPersonById
     *
     * @param personId 人物 ID
     * @return RequestConfig
     */
    fun getPersonByIdRequestConfig(personId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/persons/{person_id}".replace("{"+"person_id"+"}", encodeURIComponent(personId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get Person Image
     * 
     * @param personId 人物 ID
     * @param type 枚举值 {small|grid|large|medium}
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPersonImageById(personId: kotlin.Int, type: kotlin.String) : Unit {
        val localVarResponse = getPersonImageByIdWithHttpInfo(personId = personId, type = type)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Person Image
     * 
     * @param personId 人物 ID
     * @param type 枚举值 {small|grid|large|medium}
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getPersonImageByIdWithHttpInfo(personId: kotlin.Int, type: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = getPersonImageByIdRequestConfig(personId = personId, type = type)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPersonImageById
     *
     * @param personId 人物 ID
     * @param type 枚举值 {small|grid|large|medium}
     * @return RequestConfig
     */
    fun getPersonImageByIdRequestConfig(personId: kotlin.Int, type: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("type", listOf(type.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/persons/{person_id}/image".replace("{"+"person_id"+"}", encodeURIComponent(personId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Person Revision
     * 
     * @param revisionId 历史版本 ID
     * @return PersonRevision
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPersonRevisionByRevisionId(revisionId: kotlin.Int) : PersonRevision {
        val localVarResponse = getPersonRevisionByRevisionIdWithHttpInfo(revisionId = revisionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PersonRevision
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Person Revision
     * 
     * @param revisionId 历史版本 ID
     * @return ApiResponse<PersonRevision?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPersonRevisionByRevisionIdWithHttpInfo(revisionId: kotlin.Int) : ApiResponse<PersonRevision?> {
        val localVariableConfig = getPersonRevisionByRevisionIdRequestConfig(revisionId = revisionId)

        return request<Unit, PersonRevision>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPersonRevisionByRevisionId
     *
     * @param revisionId 历史版本 ID
     * @return RequestConfig
     */
    fun getPersonRevisionByRevisionIdRequestConfig(revisionId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/revisions/persons/{revision_id}".replace("{"+"revision_id"+"}", encodeURIComponent(revisionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get Person Revisions
     * 
     * @param personId 角色 ID
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return PagedRevision
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPersonRevisions(personId: kotlin.Int, limit: kotlin.Int? = 30, offset: kotlin.Int? = 0) : PagedRevision {
        val localVarResponse = getPersonRevisionsWithHttpInfo(personId = personId, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PagedRevision
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Person Revisions
     * 
     * @param personId 角色 ID
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return ApiResponse<PagedRevision?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPersonRevisionsWithHttpInfo(personId: kotlin.Int, limit: kotlin.Int?, offset: kotlin.Int?) : ApiResponse<PagedRevision?> {
        val localVariableConfig = getPersonRevisionsRequestConfig(personId = personId, limit = limit, offset = offset)

        return request<Unit, PagedRevision>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPersonRevisions
     *
     * @param personId 角色 ID
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return RequestConfig
     */
    fun getPersonRevisionsRequestConfig(personId: kotlin.Int, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("person_id", listOf(personId.toString()))
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/revisions/persons",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * get person related characters
     * 
     * @param personId 人物 ID
     * @return kotlin.collections.List<PersonCharacter>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRelatedCharactersByPersonId(personId: kotlin.Int) : kotlin.collections.List<PersonCharacter> {
        val localVarResponse = getRelatedCharactersByPersonIdWithHttpInfo(personId = personId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PersonCharacter>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * get person related characters
     * 
     * @param personId 人物 ID
     * @return ApiResponse<kotlin.collections.List<PersonCharacter>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRelatedCharactersByPersonIdWithHttpInfo(personId: kotlin.Int) : ApiResponse<kotlin.collections.List<PersonCharacter>?> {
        val localVariableConfig = getRelatedCharactersByPersonIdRequestConfig(personId = personId)

        return request<Unit, kotlin.collections.List<PersonCharacter>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRelatedCharactersByPersonId
     *
     * @param personId 人物 ID
     * @return RequestConfig
     */
    fun getRelatedCharactersByPersonIdRequestConfig(personId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/persons/{person_id}/characters".replace("{"+"person_id"+"}", encodeURIComponent(personId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get Subject Characters
     * 
     * @param subjectId 条目 ID
     * @return kotlin.collections.List<RelatedCharacter>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRelatedCharactersBySubjectId(subjectId: kotlin.Int) : kotlin.collections.List<RelatedCharacter> {
        val localVarResponse = getRelatedCharactersBySubjectIdWithHttpInfo(subjectId = subjectId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<RelatedCharacter>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Subject Characters
     * 
     * @param subjectId 条目 ID
     * @return ApiResponse<kotlin.collections.List<RelatedCharacter>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRelatedCharactersBySubjectIdWithHttpInfo(subjectId: kotlin.Int) : ApiResponse<kotlin.collections.List<RelatedCharacter>?> {
        val localVariableConfig = getRelatedCharactersBySubjectIdRequestConfig(subjectId = subjectId)

        return request<Unit, kotlin.collections.List<RelatedCharacter>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRelatedCharactersBySubjectId
     *
     * @param subjectId 条目 ID
     * @return RequestConfig
     */
    fun getRelatedCharactersBySubjectIdRequestConfig(subjectId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/subjects/{subject_id}/characters".replace("{"+"subject_id"+"}", encodeURIComponent(subjectId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * get character related persons
     * 
     * @param characterId 角色 ID
     * @return kotlin.collections.List<CharacterPerson>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRelatedPersonsByCharacterId(characterId: kotlin.Int) : kotlin.collections.List<CharacterPerson> {
        val localVarResponse = getRelatedPersonsByCharacterIdWithHttpInfo(characterId = characterId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CharacterPerson>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * get character related persons
     * 
     * @param characterId 角色 ID
     * @return ApiResponse<kotlin.collections.List<CharacterPerson>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRelatedPersonsByCharacterIdWithHttpInfo(characterId: kotlin.Int) : ApiResponse<kotlin.collections.List<CharacterPerson>?> {
        val localVariableConfig = getRelatedPersonsByCharacterIdRequestConfig(characterId = characterId)

        return request<Unit, kotlin.collections.List<CharacterPerson>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRelatedPersonsByCharacterId
     *
     * @param characterId 角色 ID
     * @return RequestConfig
     */
    fun getRelatedPersonsByCharacterIdRequestConfig(characterId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/characters/{character_id}/persons".replace("{"+"character_id"+"}", encodeURIComponent(characterId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get Subject Persons
     * 
     * @param subjectId 条目 ID
     * @return kotlin.collections.List<RelatedPerson>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRelatedPersonsBySubjectId(subjectId: kotlin.Int) : kotlin.collections.List<RelatedPerson> {
        val localVarResponse = getRelatedPersonsBySubjectIdWithHttpInfo(subjectId = subjectId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<RelatedPerson>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Subject Persons
     * 
     * @param subjectId 条目 ID
     * @return ApiResponse<kotlin.collections.List<RelatedPerson>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRelatedPersonsBySubjectIdWithHttpInfo(subjectId: kotlin.Int) : ApiResponse<kotlin.collections.List<RelatedPerson>?> {
        val localVariableConfig = getRelatedPersonsBySubjectIdRequestConfig(subjectId = subjectId)

        return request<Unit, kotlin.collections.List<RelatedPerson>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRelatedPersonsBySubjectId
     *
     * @param subjectId 条目 ID
     * @return RequestConfig
     */
    fun getRelatedPersonsBySubjectIdRequestConfig(subjectId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/subjects/{subject_id}/persons".replace("{"+"subject_id"+"}", encodeURIComponent(subjectId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * get character related subjects
     * 
     * @param characterId 角色 ID
     * @return kotlin.collections.List<V0RelatedSubject>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRelatedSubjectsByCharacterId(characterId: kotlin.Int) : kotlin.collections.List<V0RelatedSubject> {
        val localVarResponse = getRelatedSubjectsByCharacterIdWithHttpInfo(characterId = characterId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V0RelatedSubject>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * get character related subjects
     * 
     * @param characterId 角色 ID
     * @return ApiResponse<kotlin.collections.List<V0RelatedSubject>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRelatedSubjectsByCharacterIdWithHttpInfo(characterId: kotlin.Int) : ApiResponse<kotlin.collections.List<V0RelatedSubject>?> {
        val localVariableConfig = getRelatedSubjectsByCharacterIdRequestConfig(characterId = characterId)

        return request<Unit, kotlin.collections.List<V0RelatedSubject>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRelatedSubjectsByCharacterId
     *
     * @param characterId 角色 ID
     * @return RequestConfig
     */
    fun getRelatedSubjectsByCharacterIdRequestConfig(characterId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/characters/{character_id}/subjects".replace("{"+"character_id"+"}", encodeURIComponent(characterId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * get person related subjects
     * 
     * @param personId 人物 ID
     * @return kotlin.collections.List<V0RelatedSubject>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRelatedSubjectsByPersonId(personId: kotlin.Int) : kotlin.collections.List<V0RelatedSubject> {
        val localVarResponse = getRelatedSubjectsByPersonIdWithHttpInfo(personId = personId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V0RelatedSubject>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * get person related subjects
     * 
     * @param personId 人物 ID
     * @return ApiResponse<kotlin.collections.List<V0RelatedSubject>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRelatedSubjectsByPersonIdWithHttpInfo(personId: kotlin.Int) : ApiResponse<kotlin.collections.List<V0RelatedSubject>?> {
        val localVariableConfig = getRelatedSubjectsByPersonIdRequestConfig(personId = personId)

        return request<Unit, kotlin.collections.List<V0RelatedSubject>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRelatedSubjectsByPersonId
     *
     * @param personId 人物 ID
     * @return RequestConfig
     */
    fun getRelatedSubjectsByPersonIdRequestConfig(personId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/persons/{person_id}/subjects".replace("{"+"person_id"+"}", encodeURIComponent(personId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get Subject Relations
     * 
     * @param subjectId 条目 ID
     * @return kotlin.collections.List<V0SubjectRelation>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRelatedSubjectsBySubjectId(subjectId: kotlin.Int) : kotlin.collections.List<V0SubjectRelation> {
        val localVarResponse = getRelatedSubjectsBySubjectIdWithHttpInfo(subjectId = subjectId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<V0SubjectRelation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Subject Relations
     * 
     * @param subjectId 条目 ID
     * @return ApiResponse<kotlin.collections.List<V0SubjectRelation>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRelatedSubjectsBySubjectIdWithHttpInfo(subjectId: kotlin.Int) : ApiResponse<kotlin.collections.List<V0SubjectRelation>?> {
        val localVariableConfig = getRelatedSubjectsBySubjectIdRequestConfig(subjectId = subjectId)

        return request<Unit, kotlin.collections.List<V0SubjectRelation>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRelatedSubjectsBySubjectId
     *
     * @param subjectId 条目 ID
     * @return RequestConfig
     */
    fun getRelatedSubjectsBySubjectIdRequestConfig(subjectId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/subjects/{subject_id}/subjects".replace("{"+"subject_id"+"}", encodeURIComponent(subjectId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 获取条目
     * cache with 300s
     * @param subjectId 条目 ID
     * @return Subject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSubjectById(subjectId: kotlin.Int) : Subject {
        val localVarResponse = getSubjectByIdWithHttpInfo(subjectId = subjectId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Subject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 获取条目
     * cache with 300s
     * @param subjectId 条目 ID
     * @return ApiResponse<Subject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSubjectByIdWithHttpInfo(subjectId: kotlin.Int) : ApiResponse<Subject?> {
        val localVariableConfig = getSubjectByIdRequestConfig(subjectId = subjectId)

        return request<Unit, Subject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSubjectById
     *
     * @param subjectId 条目 ID
     * @return RequestConfig
     */
    fun getSubjectByIdRequestConfig(subjectId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/subjects/{subject_id}".replace("{"+"subject_id"+"}", encodeURIComponent(subjectId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Subject Image
     * 
     * @param subjectId 条目 ID
     * @param type 枚举值 {small|grid|large|medium|common}
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSubjectImageById(subjectId: kotlin.Int, type: kotlin.String) : Unit {
        val localVarResponse = getSubjectImageByIdWithHttpInfo(subjectId = subjectId, type = type)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Subject Image
     * 
     * @param subjectId 条目 ID
     * @param type 枚举值 {small|grid|large|medium|common}
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getSubjectImageByIdWithHttpInfo(subjectId: kotlin.Int, type: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = getSubjectImageByIdRequestConfig(subjectId = subjectId, type = type)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSubjectImageById
     *
     * @param subjectId 条目 ID
     * @param type 枚举值 {small|grid|large|medium|common}
     * @return RequestConfig
     */
    fun getSubjectImageByIdRequestConfig(subjectId: kotlin.Int, type: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("type", listOf(type.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/subjects/{subject_id}/image".replace("{"+"subject_id"+"}", encodeURIComponent(subjectId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Subject Revision
     * 
     * @param revisionId 版本 ID
     * @return SubjectRevision
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSubjectRevisionByRevisionId(revisionId: kotlin.Int) : SubjectRevision {
        val localVarResponse = getSubjectRevisionByRevisionIdWithHttpInfo(revisionId = revisionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SubjectRevision
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Subject Revision
     * 
     * @param revisionId 版本 ID
     * @return ApiResponse<SubjectRevision?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSubjectRevisionByRevisionIdWithHttpInfo(revisionId: kotlin.Int) : ApiResponse<SubjectRevision?> {
        val localVariableConfig = getSubjectRevisionByRevisionIdRequestConfig(revisionId = revisionId)

        return request<Unit, SubjectRevision>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSubjectRevisionByRevisionId
     *
     * @param revisionId 版本 ID
     * @return RequestConfig
     */
    fun getSubjectRevisionByRevisionIdRequestConfig(revisionId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/revisions/subjects/{revision_id}".replace("{"+"revision_id"+"}", encodeURIComponent(revisionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get Subject Revisions
     * 
     * @param subjectId 条目 ID
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return PagedRevision
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSubjectRevisions(subjectId: kotlin.Int, limit: kotlin.Int? = 30, offset: kotlin.Int? = 0) : PagedRevision {
        val localVarResponse = getSubjectRevisionsWithHttpInfo(subjectId = subjectId, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PagedRevision
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Subject Revisions
     * 
     * @param subjectId 条目 ID
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return ApiResponse<PagedRevision?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSubjectRevisionsWithHttpInfo(subjectId: kotlin.Int, limit: kotlin.Int?, offset: kotlin.Int?) : ApiResponse<PagedRevision?> {
        val localVariableConfig = getSubjectRevisionsRequestConfig(subjectId = subjectId, limit = limit, offset = offset)

        return request<Unit, PagedRevision>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSubjectRevisions
     *
     * @param subjectId 条目 ID
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return RequestConfig
     */
    fun getSubjectRevisionsRequestConfig(subjectId: kotlin.Int, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("subject_id", listOf(subjectId.toString()))
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/revisions/subjects",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get User Avatar by name
     * 获取用户头像，302 重定向至头像地址，设置了 username 之后无法使用 UID 查询。
     * @param username 设置了用户名之后无法使用 UID。
     * @param type 枚举值 {small|large|medium}
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getUserAvatarByName(username: kotlin.String, type: kotlin.String) : Unit {
        val localVarResponse = getUserAvatarByNameWithHttpInfo(username = username, type = type)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get User Avatar by name
     * 获取用户头像，302 重定向至头像地址，设置了 username 之后无法使用 UID 查询。
     * @param username 设置了用户名之后无法使用 UID。
     * @param type 枚举值 {small|large|medium}
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getUserAvatarByNameWithHttpInfo(username: kotlin.String, type: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = getUserAvatarByNameRequestConfig(username = username, type = type)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUserAvatarByName
     *
     * @param username 设置了用户名之后无法使用 UID。
     * @param type 枚举值 {small|large|medium}
     * @return RequestConfig
     */
    fun getUserAvatarByNameRequestConfig(username: kotlin.String, type: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("type", listOf(type.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/users/{username}/avatar".replace("{"+"username"+"}", encodeURIComponent(username.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get User by name
     * 获取用户信息
     * @param username 设置了用户名之后无法使用 UID。
     * @return User
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getUserByName(username: kotlin.String) : User {
        val localVarResponse = getUserByNameWithHttpInfo(username = username)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as User
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get User by name
     * 获取用户信息
     * @param username 设置了用户名之后无法使用 UID。
     * @return ApiResponse<User?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getUserByNameWithHttpInfo(username: kotlin.String) : ApiResponse<User?> {
        val localVariableConfig = getUserByNameRequestConfig(username = username)

        return request<Unit, User>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUserByName
     *
     * @param username 设置了用户名之后无法使用 UID。
     * @return RequestConfig
     */
    fun getUserByNameRequestConfig(username: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/users/{username}".replace("{"+"username"+"}", encodeURIComponent(username.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 获取用户单个收藏
     * 获取对应用户的收藏，查看私有收藏需要access token。
     * @param username 设置了用户名之后无法使用 UID。
     * @param subjectId 条目 ID
     * @return UserSubjectCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getUserCollection(username: kotlin.String, subjectId: kotlin.Int) : UserSubjectCollection {
        val localVarResponse = getUserCollectionWithHttpInfo(username = username, subjectId = subjectId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserSubjectCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 获取用户单个收藏
     * 获取对应用户的收藏，查看私有收藏需要access token。
     * @param username 设置了用户名之后无法使用 UID。
     * @param subjectId 条目 ID
     * @return ApiResponse<UserSubjectCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getUserCollectionWithHttpInfo(username: kotlin.String, subjectId: kotlin.Int) : ApiResponse<UserSubjectCollection?> {
        val localVariableConfig = getUserCollectionRequestConfig(username = username, subjectId = subjectId)

        return request<Unit, UserSubjectCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUserCollection
     *
     * @param username 设置了用户名之后无法使用 UID。
     * @param subjectId 条目 ID
     * @return RequestConfig
     */
    fun getUserCollectionRequestConfig(username: kotlin.String, subjectId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/users/{username}/collections/{subject_id}".replace("{"+"username"+"}", encodeURIComponent(username.toString())).replace("{"+"subject_id"+"}", encodeURIComponent(subjectId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 获取用户收藏
     * 获取对应用户的收藏，查看私有收藏需要access token。
     * @param username 设置了用户名之后无法使用 UID。
     * @param subjectType 条目类型，默认为全部  具体含义见 [SubjectType](#model-SubjectType) (optional)
     * @param type 收藏类型，默认为全部  具体含义见 [CollectionType](#model-CollectionType) (optional)
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return PagedUserCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getUserCollectionsByUsername(username: kotlin.String, subjectType: SubjectType? = null, type: SubjectCollectionType? = null, limit: kotlin.Int? = 30, offset: kotlin.Int? = 0) : PagedUserCollection {
        val localVarResponse = getUserCollectionsByUsernameWithHttpInfo(username = username, subjectType = subjectType, type = type, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PagedUserCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 获取用户收藏
     * 获取对应用户的收藏，查看私有收藏需要access token。
     * @param username 设置了用户名之后无法使用 UID。
     * @param subjectType 条目类型，默认为全部  具体含义见 [SubjectType](#model-SubjectType) (optional)
     * @param type 收藏类型，默认为全部  具体含义见 [CollectionType](#model-CollectionType) (optional)
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return ApiResponse<PagedUserCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getUserCollectionsByUsernameWithHttpInfo(username: kotlin.String, subjectType: SubjectType?, type: SubjectCollectionType?, limit: kotlin.Int?, offset: kotlin.Int?) : ApiResponse<PagedUserCollection?> {
        val localVariableConfig = getUserCollectionsByUsernameRequestConfig(username = username, subjectType = subjectType, type = type, limit = limit, offset = offset)

        return request<Unit, PagedUserCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUserCollectionsByUsername
     *
     * @param username 设置了用户名之后无法使用 UID。
     * @param subjectType 条目类型，默认为全部  具体含义见 [SubjectType](#model-SubjectType) (optional)
     * @param type 收藏类型，默认为全部  具体含义见 [CollectionType](#model-CollectionType) (optional)
     * @param limit 分页参数 (optional, default to 30)
     * @param offset 分页参数 (optional, default to 0)
     * @return RequestConfig
     */
    fun getUserCollectionsByUsernameRequestConfig(username: kotlin.String, subjectType: SubjectType?, type: SubjectCollectionType?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (subjectType != null) {
                    put("subject_type", listOf(subjectType.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/users/{username}/collections".replace("{"+"username"+"}", encodeURIComponent(username.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 章节收藏信息
     * 
     * @param episodeId 章节 ID
     * @return UserEpisodeCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getUserEpisodeCollection(episodeId: kotlin.Int) : UserEpisodeCollection {
        val localVarResponse = getUserEpisodeCollectionWithHttpInfo(episodeId = episodeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserEpisodeCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 章节收藏信息
     * 
     * @param episodeId 章节 ID
     * @return ApiResponse<UserEpisodeCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getUserEpisodeCollectionWithHttpInfo(episodeId: kotlin.Int) : ApiResponse<UserEpisodeCollection?> {
        val localVariableConfig = getUserEpisodeCollectionRequestConfig(episodeId = episodeId)

        return request<Unit, UserEpisodeCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUserEpisodeCollection
     *
     * @param episodeId 章节 ID
     * @return RequestConfig
     */
    fun getUserEpisodeCollectionRequestConfig(episodeId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/users/-/collections/-/episodes/{episode_id}".replace("{"+"episode_id"+"}", encodeURIComponent(episodeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 章节收藏信息
     * 
     * @param subjectId 条目 ID
     * @param offset 分页参数 (optional, default to 0)
     * @param limit 分页参数 (optional, default to 100)
     * @param episodeType 章节类型，不传则不按照章节进行筛选 (optional)
     * @return GetUserSubjectEpisodeCollection200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getUserSubjectEpisodeCollection(subjectId: kotlin.Int, offset: kotlin.Int? = 0, limit: kotlin.Int? = 100, episodeType: EpType? = null) : GetUserSubjectEpisodeCollection200Response {
        val localVarResponse = getUserSubjectEpisodeCollectionWithHttpInfo(subjectId = subjectId, offset = offset, limit = limit, episodeType = episodeType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetUserSubjectEpisodeCollection200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 章节收藏信息
     * 
     * @param subjectId 条目 ID
     * @param offset 分页参数 (optional, default to 0)
     * @param limit 分页参数 (optional, default to 100)
     * @param episodeType 章节类型，不传则不按照章节进行筛选 (optional)
     * @return ApiResponse<GetUserSubjectEpisodeCollection200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getUserSubjectEpisodeCollectionWithHttpInfo(subjectId: kotlin.Int, offset: kotlin.Int?, limit: kotlin.Int?, episodeType: EpType?) : ApiResponse<GetUserSubjectEpisodeCollection200Response?> {
        val localVariableConfig = getUserSubjectEpisodeCollectionRequestConfig(subjectId = subjectId, offset = offset, limit = limit, episodeType = episodeType)

        return request<Unit, GetUserSubjectEpisodeCollection200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUserSubjectEpisodeCollection
     *
     * @param subjectId 条目 ID
     * @param offset 分页参数 (optional, default to 0)
     * @param limit 分页参数 (optional, default to 100)
     * @param episodeType 章节类型，不传则不按照章节进行筛选 (optional)
     * @return RequestConfig
     */
    fun getUserSubjectEpisodeCollectionRequestConfig(subjectId: kotlin.Int, offset: kotlin.Int?, limit: kotlin.Int?, episodeType: EpType?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (episodeType != null) {
                    put("episode_type", listOf(episodeType.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/users/-/collections/{subject_id}/episodes".replace("{"+"subject_id"+"}", encodeURIComponent(subjectId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create a new index
     * 
     * @return Index
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun newIndex() : Index {
        val localVarResponse = newIndexWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Index
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a new index
     * 
     * @return ApiResponse<Index?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun newIndexWithHttpInfo() : ApiResponse<Index?> {
        val localVariableConfig = newIndexRequestConfig()

        return request<Unit, Index>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation newIndex
     *
     * @return RequestConfig
     */
    fun newIndexRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v0/indices",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 修改用户单个收藏
     * 修改条目收藏状态  由于直接修改剧集条目的完成度可能会引起意料之外效果，只能用于修改书籍类条目的完成度。  PATCH 方法的所有请求体字段均可选 
     * @param subjectId 条目 ID
     * @param userSubjectCollectionModifyPayload  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchUserCollection(subjectId: kotlin.Int, userSubjectCollectionModifyPayload: UserSubjectCollectionModifyPayload? = null) : Unit {
        val localVarResponse = patchUserCollectionWithHttpInfo(subjectId = subjectId, userSubjectCollectionModifyPayload = userSubjectCollectionModifyPayload)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 修改用户单个收藏
     * 修改条目收藏状态  由于直接修改剧集条目的完成度可能会引起意料之外效果，只能用于修改书籍类条目的完成度。  PATCH 方法的所有请求体字段均可选 
     * @param subjectId 条目 ID
     * @param userSubjectCollectionModifyPayload  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun patchUserCollectionWithHttpInfo(subjectId: kotlin.Int, userSubjectCollectionModifyPayload: UserSubjectCollectionModifyPayload?) : ApiResponse<Unit?> {
        val localVariableConfig = patchUserCollectionRequestConfig(subjectId = subjectId, userSubjectCollectionModifyPayload = userSubjectCollectionModifyPayload)

        return request<UserSubjectCollectionModifyPayload, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchUserCollection
     *
     * @param subjectId 条目 ID
     * @param userSubjectCollectionModifyPayload  (optional)
     * @return RequestConfig
     */
    fun patchUserCollectionRequestConfig(subjectId: kotlin.Int, userSubjectCollectionModifyPayload: UserSubjectCollectionModifyPayload?) : RequestConfig<UserSubjectCollectionModifyPayload> {
        val localVariableBody = userSubjectCollectionModifyPayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/v0/users/-/collections/{subject_id}".replace("{"+"subject_id"+"}", encodeURIComponent(subjectId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 章节收藏信息
     * 同时会重新计算条目的完成度 
     * @param subjectId 条目 ID
     * @param patchUserSubjectEpisodeCollectionRequest  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchUserSubjectEpisodeCollection(subjectId: kotlin.Int, patchUserSubjectEpisodeCollectionRequest: PatchUserSubjectEpisodeCollectionRequest? = null) : Unit {
        val localVarResponse = patchUserSubjectEpisodeCollectionWithHttpInfo(subjectId = subjectId, patchUserSubjectEpisodeCollectionRequest = patchUserSubjectEpisodeCollectionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 章节收藏信息
     * 同时会重新计算条目的完成度 
     * @param subjectId 条目 ID
     * @param patchUserSubjectEpisodeCollectionRequest  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun patchUserSubjectEpisodeCollectionWithHttpInfo(subjectId: kotlin.Int, patchUserSubjectEpisodeCollectionRequest: PatchUserSubjectEpisodeCollectionRequest?) : ApiResponse<Unit?> {
        val localVariableConfig = patchUserSubjectEpisodeCollectionRequestConfig(subjectId = subjectId, patchUserSubjectEpisodeCollectionRequest = patchUserSubjectEpisodeCollectionRequest)

        return request<PatchUserSubjectEpisodeCollectionRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchUserSubjectEpisodeCollection
     *
     * @param subjectId 条目 ID
     * @param patchUserSubjectEpisodeCollectionRequest  (optional)
     * @return RequestConfig
     */
    fun patchUserSubjectEpisodeCollectionRequestConfig(subjectId: kotlin.Int, patchUserSubjectEpisodeCollectionRequest: PatchUserSubjectEpisodeCollectionRequest?) : RequestConfig<PatchUserSubjectEpisodeCollectionRequest> {
        val localVariableBody = patchUserSubjectEpisodeCollectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/v0/users/-/collections/{subject_id}/episodes".replace("{"+"subject_id"+"}", encodeURIComponent(subjectId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 新增或修改用户单个收藏
     * 修改条目收藏状态, 如果不存在则创建，如果存在则修改  由于直接修改剧集条目的完成度可能会引起意料之外效果，只能用于修改书籍类条目的完成度。  方法的所有请求体字段均可选 
     * @param subjectId 条目 ID
     * @param userSubjectCollectionModifyPayload  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postUserCollection(subjectId: kotlin.Int, userSubjectCollectionModifyPayload: UserSubjectCollectionModifyPayload? = null) : Unit {
        val localVarResponse = postUserCollectionWithHttpInfo(subjectId = subjectId, userSubjectCollectionModifyPayload = userSubjectCollectionModifyPayload)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 新增或修改用户单个收藏
     * 修改条目收藏状态, 如果不存在则创建，如果存在则修改  由于直接修改剧集条目的完成度可能会引起意料之外效果，只能用于修改书籍类条目的完成度。  方法的所有请求体字段均可选 
     * @param subjectId 条目 ID
     * @param userSubjectCollectionModifyPayload  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun postUserCollectionWithHttpInfo(subjectId: kotlin.Int, userSubjectCollectionModifyPayload: UserSubjectCollectionModifyPayload?) : ApiResponse<Unit?> {
        val localVariableConfig = postUserCollectionRequestConfig(subjectId = subjectId, userSubjectCollectionModifyPayload = userSubjectCollectionModifyPayload)

        return request<UserSubjectCollectionModifyPayload, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postUserCollection
     *
     * @param subjectId 条目 ID
     * @param userSubjectCollectionModifyPayload  (optional)
     * @return RequestConfig
     */
    fun postUserCollectionRequestConfig(subjectId: kotlin.Int, userSubjectCollectionModifyPayload: UserSubjectCollectionModifyPayload?) : RequestConfig<UserSubjectCollectionModifyPayload> {
        val localVariableBody = userSubjectCollectionModifyPayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v0/users/-/collections/{subject_id}".replace("{"+"subject_id"+"}", encodeURIComponent(subjectId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 更新章节收藏信息
     * 
     * @param episodeId 章节 ID
     * @param putUserEpisodeCollectionRequest  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun putUserEpisodeCollection(episodeId: kotlin.Int, putUserEpisodeCollectionRequest: PutUserEpisodeCollectionRequest? = null) : Unit {
        val localVarResponse = putUserEpisodeCollectionWithHttpInfo(episodeId = episodeId, putUserEpisodeCollectionRequest = putUserEpisodeCollectionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 更新章节收藏信息
     * 
     * @param episodeId 章节 ID
     * @param putUserEpisodeCollectionRequest  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun putUserEpisodeCollectionWithHttpInfo(episodeId: kotlin.Int, putUserEpisodeCollectionRequest: PutUserEpisodeCollectionRequest?) : ApiResponse<Unit?> {
        val localVariableConfig = putUserEpisodeCollectionRequestConfig(episodeId = episodeId, putUserEpisodeCollectionRequest = putUserEpisodeCollectionRequest)

        return request<PutUserEpisodeCollectionRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation putUserEpisodeCollection
     *
     * @param episodeId 章节 ID
     * @param putUserEpisodeCollectionRequest  (optional)
     * @return RequestConfig
     */
    fun putUserEpisodeCollectionRequestConfig(episodeId: kotlin.Int, putUserEpisodeCollectionRequest: PutUserEpisodeCollectionRequest?) : RequestConfig<PutUserEpisodeCollectionRequest> {
        val localVariableBody = putUserEpisodeCollectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/v0/users/-/collections/-/episodes/{episode_id}".replace("{"+"episode_id"+"}", encodeURIComponent(episodeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 条目搜索
     * ## 实验性 API， 本 schema 和实际的 API 行为都可能随时发生改动  目前支持的筛选条件包括: - &#x60;type&#x60;: 条目类型，参照 &#x60;SubjectType&#x60; enum， &#x60;或&#x60;。 - &#x60;tag&#x60;: 标签，可以多次出现。&#x60;且&#x60; 关系。 - &#x60;airdate&#x60;: 播出日期/发售日期。&#x60;且&#x60; 关系。 - &#x60;rating&#x60;: 用于搜索指定评分的条目。&#x60;且&#x60; 关系。 - &#x60;rank&#x60;: 用于搜索指定排名的条目。&#x60;且&#x60; 关系。 - &#x60;nsfw&#x60;: 使用 &#x60;include&#x60; 包含NSFW搜索结果。默认排除搜索NSFW条目。无权限情况下忽略此选项，不会返回NSFW条目。  不同筛选条件之间为 &#x60;且&#x60;   由于目前 meilisearch 的一些问题，条目排名更新并不会触发搜索数据更新，所以条目排名可能是过期数据。  希望未来版本的 meilisearch 能解决相关的问题。 
     * @param limit 分页参数 (optional)
     * @param offset 分页参数 (optional)
     * @param searchSubjectsRequest  (optional)
     * @return SearchSubjects200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchSubjects(limit: kotlin.Int? = null, offset: kotlin.Int? = null, searchSubjectsRequest: SearchSubjectsRequest? = null) : SearchSubjects200Response {
        val localVarResponse = searchSubjectsWithHttpInfo(limit = limit, offset = offset, searchSubjectsRequest = searchSubjectsRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SearchSubjects200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 条目搜索
     * ## 实验性 API， 本 schema 和实际的 API 行为都可能随时发生改动  目前支持的筛选条件包括: - &#x60;type&#x60;: 条目类型，参照 &#x60;SubjectType&#x60; enum， &#x60;或&#x60;。 - &#x60;tag&#x60;: 标签，可以多次出现。&#x60;且&#x60; 关系。 - &#x60;airdate&#x60;: 播出日期/发售日期。&#x60;且&#x60; 关系。 - &#x60;rating&#x60;: 用于搜索指定评分的条目。&#x60;且&#x60; 关系。 - &#x60;rank&#x60;: 用于搜索指定排名的条目。&#x60;且&#x60; 关系。 - &#x60;nsfw&#x60;: 使用 &#x60;include&#x60; 包含NSFW搜索结果。默认排除搜索NSFW条目。无权限情况下忽略此选项，不会返回NSFW条目。  不同筛选条件之间为 &#x60;且&#x60;   由于目前 meilisearch 的一些问题，条目排名更新并不会触发搜索数据更新，所以条目排名可能是过期数据。  希望未来版本的 meilisearch 能解决相关的问题。 
     * @param limit 分页参数 (optional)
     * @param offset 分页参数 (optional)
     * @param searchSubjectsRequest  (optional)
     * @return ApiResponse<SearchSubjects200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchSubjectsWithHttpInfo(limit: kotlin.Int?, offset: kotlin.Int?, searchSubjectsRequest: SearchSubjectsRequest?) : ApiResponse<SearchSubjects200Response?> {
        val localVariableConfig = searchSubjectsRequestConfig(limit = limit, offset = offset, searchSubjectsRequest = searchSubjectsRequest)

        return request<SearchSubjectsRequest, SearchSubjects200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchSubjects
     *
     * @param limit 分页参数 (optional)
     * @param offset 分页参数 (optional)
     * @param searchSubjectsRequest  (optional)
     * @return RequestConfig
     */
    fun searchSubjectsRequestConfig(limit: kotlin.Int?, offset: kotlin.Int?, searchSubjectsRequest: SearchSubjectsRequest?) : RequestConfig<SearchSubjectsRequest> {
        val localVariableBody = searchSubjectsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v0/search/subjects",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Uncollect index for current user
     * 为当前用户取消收藏一条目录
     * @param indexId 目录 ID
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uncollectIndexByIndexIdAndUserId(indexId: kotlin.Int) : Unit {
        val localVarResponse = uncollectIndexByIndexIdAndUserIdWithHttpInfo(indexId = indexId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Uncollect index for current user
     * 为当前用户取消收藏一条目录
     * @param indexId 目录 ID
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun uncollectIndexByIndexIdAndUserIdWithHttpInfo(indexId: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = uncollectIndexByIndexIdAndUserIdRequestConfig(indexId = indexId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uncollectIndexByIndexIdAndUserId
     *
     * @param indexId 目录 ID
     * @return RequestConfig
     */
    fun uncollectIndexByIndexIdAndUserIdRequestConfig(indexId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/v0/indices/{index_id}/collect".replace("{"+"index_id"+"}", encodeURIComponent(indexId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
